# תוכנית שיפור זמני טעינת התזרים ועדכון דינמי

## מצב נוכחי
- `CashFlowDashboardViewModel.swift` (לב לבניית המסך) קורא ב־`loadInitial()` ל־`refreshData()` שמבצע קריאת נתונים אחת לכל הקטגוריות והתקופה (כולל `per_page=5000`) ואז בונה את כל המסכים (כרטיסים + גרפים). כל מחיקה/עדכון מובילה לקריאה חוזרת מלאה.
- `refreshData()` מריץ שלוש קריאות מקבילות (תזרים, מטרות חודשיות וקטגוריות ריקות) אבל עדיין ממתין לכך שהכול יסתיים כדי לבנות מצב חדש; כל טרנזקציה־שינוי מגרד את כל ה־state במקום לעדכן מקומית.
- לא קיימים חצים מוגדרים שמחזיקים נתונים בין טעינות או תהליכי incremental, לכן כל גלישה בזמן/שינוי מביא לרענון מלא של כל המידע, ולכן זה איטי ומרגיש כמו "שנה".

## יעדים
1. לצמצם את הנתונים שמורדים ברשת לסט מתאים לפי פוקוס (כרטיס הוצאות, גרף היסטורי, תזרים מסוים).
2. לאפשר טעינה דינמית: קריאה קצרה להתחלת המסך ומחייה מקומית של `transactions` / `pendingTransactions` בעת מחיקה או עדכון.
3. לשמור על חוויית משתמש תזריםית: לציין מה נטען, להמשיך לעבוד עם חלק מהמידע בזמן שהחלק האחר עדיין בתהליך.

## שלבים מפורטים
1. **מדידה ודיאגנוסטיקה**
   - תעדוף `AppLogger`/מעקב זמן־שירותים ב־`refreshData()` (זמן רשת, דחיסת JSON, בניית סיכומים) כדי לאתר אם הבקשה עצמה כבד, העיבוד או שניהם.
   - לייצר `@Published var isCachingTransactions = false` או דגל דומה שמראה מתי המערכת משתמשת בנתונים קיימים מול הטענה חדשה.

2. **פרגמנטציה של הטעינה**
   - ליישם request מופרד ל־`currentMonthDate` ו־`timeRange`. למשל:
     * קריאה מהירה רק לחודש הנוכחי (קריאות קטנות ל־cards).
     * קריאת גרפים ממחזור של 3/6/12 חודשים בצורה אסינכרונית שלא חוסמת את ה־UI: `loadChartsOnly()` ו־`loadCurrentMonthOnly()`.
   - להשתמש ב־`TaskGroup` כדי להריץ את החלקים במקביל ולדרג עדכון state ברגע שכל חלק מוכן. כך אפשר להציג כרטיסים ועדיין לטעון גרפים ברקע.

3. **הגדרת מטמון קבצי טרנזקציות**
   - לשמור במילוי זיכרון (למשל `CashFlowTransactionStore`) מפה של תאריכים/מטבע/flowId כך שבגלילה קדימה/אחורה לא נדרש לטעון את ה־5000 בשנית.
   - לכתוב לוגיקה שממזגת נתונים חדשים מ־`fetchTransactionsFlexible` עם המידע הקיים, במקום להחליף את כל המערך (`transactions = transactionsAll`). כך גם ניתן להחזיר עדכונים מהשרת עם טרנזקציות קטנות בלי לאבד את השאר.
   - לוודא שהמטמון מנקה את עצמו בעת שינוי `cashFlow` או שינוי `baseURL`.

4. **עדכון דינמי בעת מחיקות/שינויים**
   - כשמשתמש מוחק עסקה, להשתמש ב־`apiClient` חדש שמחזיר רק את הטרנזקציה הזו. במקום `refreshData()`, להסיר אותה מהמיין־סטייט (`transactions`, `pendingTransactions`, `orderedItems`, `expenseCategorySlices` וכו') דרך `removeTransaction(_:)`.
   - לבנות helper כגון `mutateState(using transactionDiff: TransactionDiff)` שמחשב כיצד לעדכן סיכומים ותצוגות (incomeTotal, cumulativeSeries וכו') בלי להטען מחדש.
   - להוסיף `@Published var lastMutation: MutationStatus` כדי שה־View יראה אנימציה/תיאום (עומד/כישלון) בזמן שמעדכנים מקומית.

5. **שיפור חוויית משתמש ברשת חלשה**
   - כשהטענת נתונים ארוכה, להציג placeholders לפי החלקים שכבר מוכנים.
   - להוסיף כפתור "רענון חלקי" למסך שמפעיל רק את החלק שלא טען (גרפים לעומת כרטיסים).

6. **בדיקות ואימות**
   - להוסיף יחידות בדיקה ל־`CashFlowDashboardViewModel` (במצב מוזמן) שתבדוק ש־`buildCharts`/`buildCardsForCurrentMonth` מתווספים נכון לאחר עדכון מקומי.
   - להריץ `swift test` (אם קיימים מבחנים) או לבדוק `Previews` כדי לוודא שה־UI מתעדכן רגעית.

## שלבים קרובים
1. ליישם מדידה של זמן רענון ולזהות באיזה קטע הכי כבד.
2. ליצור מודול `TransactionCache` ולשלב אותו ב־`refreshData`/`delete`.
3. לעדכן את `RootView`/`ContentView` כדי להציג אינדיקטורים לפעולות חלקיות.

לאחר השלמתם, נשקול לחבר `SnapshotTesting` למודולים החדשים כדי לזהות שינויים לא מתוכננים בזמן רענון נתונים.
