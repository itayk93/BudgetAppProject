# תוכנית יישום: זמני טעינה אפסיים ב־iOS

## ממצאים מהבדיקה
- לוגים מראים שתי קריאות `/transactions` במקביל: כ‑750 עסקאות (~5.7s) עבור כרטיסי החודש וכ‑2.1k עסקאות (~6.6s) עבור גרפים; הבנייה המקומית מוסיפה עוד ~5s, כך שזמן כולל מתקרב ל‑10s.
- `CashflowCardsView.onAppear` קורא `loadInitial()` ואז `refreshData()` שוב, למרות ש־`loadInitial()` כבר מפעיל `refreshData()` – כלומר הטעינה מתבצעת פעמיים בכל כניסה למסך.
- המטמון (`CashFlowTransactionStore`) הוא בזיכרון בלבד; בכל הפעלה/חזרה מה־background כל הנתונים יורדים מחדש.
- חישובים כבדים מתבצעים שוב ושוב: `Transaction.parsedDate` בונה פורמטר חדש בכל גישה, וסינונים/קיבוצים מרובים ב־`buildCardsForCurrentMonth` ו־`buildCharts` רצים על אותו מערך של אלפי עסקאות.
- נתוני הגרפים מחושבים מקומית על בסיס כל העסקאות במקום להשתמש בנתוני אגרגציה (למשל `DashboardService` קיים אך לא בשימוש).

## יעדי ביצועים
- מסך הכרטיסים צריך להציג נתונים קיימים תוך <1s גם בכניסה ראשונה (קריאה אחת קטנה לריענון בלבד).
- גרפים צריכים להיטען ברקע ולא לחסום UI; יעד <2s לרענון גרפים מלא, ו־0s אם יש מטמון עדכני.
- אין יותר מקרי כפל טעינה או קריאה של אותו טווח נתונים פעמיים.

## שלבי יישום מוצעים
1) **תיקוני בזק (Day 0–1)**
- להסיר את הכפילות ב־`CashflowCardsView.onAppear` ולהשאיר קריאה אחת לטעינה הראשונית.
- לחסום רענון כפול כשכבר יש נתונים בטווח המבוקש (`hasMonths` + דגל שמונע `refreshData` חוזר).
- לצמצם את קריאת הגרפים הראשונית למספר חודשי ברירת מחדל קטן (למשל 3) ולתת למשתמש לבחור טווח ארוך יותר רק אחרי שהמסך מוצג.

2) **מדידה ושקיפות**
- להרחיב את `RefreshDiagnostics` כך שישמור גם גודל payload, מספר עסקאות, וזמן דחיסה/פענוח JSON.
- להוסיף `os_signpost`/`measure` סביב החלקים הכבדים (`buildCardsForCurrentMonth`, `buildCharts`) כדי לזהות צווארי בקבוק של CPU.

3) **מטמון מתמשך וטעינה מיידית**
- להרחיב את `CashFlowTransactionStore` לכתיבה/קריאה לדיסק (JSON gzipped או SQLite) לפי `ScopeKey` + `monthKey`, ולהעלות את המצב מהדיסק לפני כל רשת.
- להוסיף `lastSyncedAt` per cashFlow כדי להריץ רק `HEAD/If-None-Match` או `updated_after` ולדלג על הורדה אם אין שינוי.
- לשמור גם את סיכומי הגרפים האחרונים כדי להציג אותם מיידית בזמן שריענון רץ ברקע.

4) **אופטימיזציית רשת**
- להוסיף פרמטר `updated_after`/`changes_since` ל־`fetchTransactionsFlexible` (בדומה ללוגיקת הווב) כדי למשוך רק שינויים במקום טווח מלא.
- להשתמש ב־`DashboardService.fetchDashboard` (אגרגציה שרתית) לבניית הגרפים ולהימנע מהורדת אלפי עסקאות עבור סדרות חודשיות.
- לצמצם `per_page` ל‑min הדרוש (למשל 200–400 לעומת 750/2100) ולהוסיף pagination lazy בעת גלילה/חיפוש.

5) **אופטימיזציית עיבוד מקומי**
- להפוך את `Transaction.parsedDate` ו־`flowMonthKey` לשדות מחושבים פעם אחת בעת decoding עם פורמטרים סטטיים (ללא יצירת `DateFormatter` בכל גישה).
- לאחד סינונים/קיבוצים: לעבור על העסקאות בלולאה אחת שמחשבת במקביל הכנסות/הוצאות/סכומי שבועות/קטגוריות במקום שלושה `filter + reduce`.
- למיין פעם אחת בלבד (לדוגמה, למיין חודשית לפני הפצה לכרטיסים ולגרפים) ולהימנע מ־`sorted` כפול.

6) **סדר פעולות ברקע וחוויית משתמש**
- להציג את המצב מהמטמון מיד, להפעיל ריענון ברקע עם diff מקומי (`mutateState`) במקום `refreshData` מלא בכל שינוי/מחיקה.
- להוריד את `pendingTransactions` רק אחרי שהכרטיסים מוצגים, ולא כחלק מהטעינה החוסמת.
- להוסיף אינדיקציה קטנה מתי מוצג מטמון ומתי ריענון חי רץ (דגל קיים `isCachingTransactions`, להבליט ב־UI).

## קבצים רלוונטיים לשינויים
- `BudgetApp/Views/CashflowCardsView.swift` – מניעת רענון כפול וסדר הפעולות ב־onAppear.
- `BudgetApp/ViewModels/CashFlowDashboardViewModel.swift` – המטמון, הפרמטרים לרשת, צמצום עיבוד, שילוב אגרגציה לגרפים.
- `BudgetApp/Services/APIClient.swift`, `BudgetApp/Services/TransactionsService.swift` – תמיכה ב־`updated_after`/ETag וגרסאות דחוסות.
- `BudgetApp/Helpers/CashFlowTransactionStore.swift` – הרחבת מטמון לזיכרון+דיסק ודגלי תאימות.

## קריטריוני קבלה
- כניסה לדף ראשי עם נתונים קיימים: זמן עד ציור כרטיסים <1s ללא רשת.
- רענון מלא (רשת + בנייה) לטווח ברירת מחדל: <2s ברשת מקומית, <4s ברשת סלולרית; רשת 0s כשהשרת מחזיר 304/אין שינויים.
- אין קריאות `/transactions` כפולות לאותו טווח; ניטור מציג payload וגודל זיכרון לפני ואחרי הבנייה.
